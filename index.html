<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Experiencia 3D Fluida</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; 
            font-family: sans-serif;
        }

        #intro-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s ease;
        }

        #start-btn {
            background: transparent; color: white; border: 1px solid rgba(255,255,255,0.6);
            padding: 15px 40px; font-size: 1rem; text-transform: uppercase;
            letter-spacing: 3px; cursor: pointer; border-radius: 50px;
            transition: all 0.3s;
        }

        #start-btn:hover { background: white; color: black; }

        .viewer-container {
            position: relative;
            width: 100%; max-width: 100%;
            aspect-ratio: 1.56 / 1; 
            background-color: #000;
            cursor: grab; touch-action: none; user-select: none;
            -webkit-tap-highlight-color: transparent; 
            opacity: 0; transition: opacity 1s ease;
            overflow: hidden;
        }

        .viewer-container.active { opacity: 1; }
        .viewer-container:active { cursor: grabbing; }

        #product-image {
            width: 100%; height: 100%;
            object-fit: fill; 
            display: block; pointer-events: none; -webkit-user-drag: none;
            transform-origin: center center;
            will-change: transform; /* Optimización vital para animación */
            transform: scale(1);
        }

        #demo-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; pointer-events: none; }
    </style>
</head>
<body>

    <div id="intro-overlay">
        <button id="start-btn" onclick="iniciarExperiencia()">Iniciar</button>
    </div>

    <div class="viewer-container" id="container">
        <canvas id="demo-canvas"></canvas>
        <img id="product-image" src="" alt="Modelo 3D">
    </div>

    <script>
        // ==========================================
        // CONFIGURACIÓN
        // ==========================================
        const config = {
            totalX: 16,        
            totalY: 16,        
            folderPath: "renders/", 
            filePrefix: "modelo",   
            fileExtension: ".jpg",  
            
            // Sensibilidad de entrada (cuanto arrastre = 1 foto de distancia)
            sensitivity: 65,  
            
            // Zoom máximo (1%)
            maxZoomDelta: 0.01,

            // VELOCIDAD DE PERSECUCIÓN
            // Cuantos frames puede saltar el sistema POR FRAME DE NAVEGADOR (16ms)
            // 1 = Estricto (muestra TODAS las fotos intermedias, puede sentirse lento si arrastras muy lejos)
            // 2 o 3 = Compromiso (salta de 2 en 2 si vas muy rápido, pero imperceptible al ojo)
            // Dado que pediste "obligatoriamente", lo dejaremos en 1.
            chaseSpeed: 1
        };

        // ==========================================
        // VARIABLES DE ESTADO
        // ==========================================
        let state = {
            // Posición REAL actual (lo que se ve en pantalla)
            currentFrameX: 0, 
            currentFrameY: 0,
            
            // Posición OBJETIVO (donde está tu dedo o hacia donde queremos ir)
            targetDragX: 0,
            targetDragY: 0,

            // Variables de interacción
            isDragging: false,
            startX: 0,
            startY: 0,
            
            // Para el zoom
            currentDragMagnitude: 0, 
            
            // Referencia para el loop de animación
            animationId: null
        };

        const container = document.getElementById('container');
        const imgElement = document.getElementById('product-image');
        const demoCanvas = document.getElementById('demo-canvas');
        const introOverlay = document.getElementById('intro-overlay');
        let demoActive = false;

        // ==========================================
        // CARGA
        // ==========================================
        imgElement.onload = function() {
            demoActive = false;
            demoCanvas.style.display = 'none';
            imgElement.style.display = 'block';
        };
        imgElement.onerror = function() {
            if(imgElement.src && imgElement.src !== window.location.href) activarModoDemo();
        };

        // ==========================================
        // INICIO
        // ==========================================
        function iniciarExperiencia() {
            const docEl = document.documentElement;
            if (docEl.requestFullscreen) docEl.requestFullscreen();
            else if (docEl.webkitRequestFullscreen) docEl.webkitRequestFullscreen();
            
            introOverlay.style.opacity = '0';
            setTimeout(() => {
                introOverlay.style.display = 'none';
                container.classList.add('active');
                
                // Inicializar posición inicial (Centro aprox)
                // Frame 8, 8
                state.currentFrameX = 8 * config.sensitivity;
                state.currentFrameY = 8 * config.sensitivity;
                state.targetDragX = -state.currentFrameX;
                state.targetDragY = state.currentFrameY;
                
                // Arrancar el motor de renderizado continuo
                loopRender();
            }, 500);
        }

        // ==========================================
        // MOTOR DE RENDERIZADO (Game Loop)
        // ==========================================
        // Esta función se ejecuta 60 veces por segundo aprox.
        function loopRender() {
            
            // 1. Convertir la posición del dedo (Target) a "Coordenadas de Frames"
            // Invertimos X para que el arrastre sea natural
            let targetFrameRawX = -state.targetDragX;
            let targetFrameRawY = state.targetDragY;

            // 2. Lógica de PERSECUCIÓN (Interpolación paso a paso)
            // Si lo que mostramos (current) es diferente a lo que pide el dedo (target)...
            
            // --- Eje X ---
            let diffX = targetFrameRawX - state.currentFrameX;
            if (Math.abs(diffX) > 0) {
                // Si la diferencia es positiva, sumamos. Si negativa, restamos.
                // Math.sign devuelve 1 o -1.
                // Multiplicamos por chaseSpeed (1) para asegurar que pase frame por frame
                let step = Math.sign(diffX) * Math.min(Math.abs(diffX), config.sensitivity * config.chaseSpeed);
                
                // Truco: Para obligar a ver todas las fotos, nos movemos pixel a pixel del "sensitivity"
                // Pero para que no sea eterno, avanzamos en bloques controlados.
                // Aquí forzamos que avance hacia el objetivo
                if (Math.abs(diffX) >= config.sensitivity) {
                     state.currentFrameX += Math.sign(diffX) * config.sensitivity;
                } else {
                    // Ajuste fino (sub-pixel)
                    state.currentFrameX = targetFrameRawX; 
                }
            }

            // --- Eje Y ---
            let diffY = targetFrameRawY - state.currentFrameY;
            if (Math.abs(diffY) > 0) {
                 if (Math.abs(diffY) >= config.sensitivity) {
                     state.currentFrameY += Math.sign(diffY) * config.sensitivity;
                } else {
                    state.currentFrameY = targetFrameRawY;
                }
            }

            // 3. CALCULAR QUÉ FOTO MOSTRAR
            // Convertimos la posición "perseguidora" en índices de 0 a 15
            let rawIndexX = Math.floor(state.currentFrameX / config.sensitivity);
            let rawIndexY = Math.floor(state.currentFrameY / config.sensitivity);

            // "Clamping" (Limitar para no salir del rango de fotos)
            let safeX = Math.max(0, Math.min(config.totalX - 1, rawIndexX));
            let safeY = Math.max(0, Math.min(config.totalY - 1, rawIndexY));

            // 4. ACTUALIZAR IMAGEN
            // Solo actualizamos el DOM si el cálculo dio una foto nueva
            // IMPORTANTE: Aquí es donde ocurre la magia. Como el "current" avanza
            // paso a paso hacia el "target", pasará por safeX=4, luego safeX=5, etc.
            let imageNumber = (safeX * config.totalY) + safeY;
            let numberString = imageNumber.toString().padStart(4, '0');
            const filename = `${config.folderPath}${config.filePrefix}${numberString}${config.fileExtension}`;

            if (!imgElement.src.includes(filename)) {
                imgElement.src = filename;
            }
            
            if (demoActive) drawDemoCube(safeX, safeY, filename);

            // 5. ZOOM PROGRESIVO
            let progress = Math.min(state.currentDragMagnitude / config.sensitivity, 1.0);
            let currentScale = 1 + (progress * config.maxZoomDelta);
            imgElement.style.transform = `scale(${currentScale})`;

            // Solicitar el siguiente frame
            state.animationId = requestAnimationFrame(loopRender);
        }

        // ==========================================
        // EVENTOS DE ENTRADA (Solo actualizan el Target)
        // ==========================================
        function startDrag(clientX, clientY) {
            state.isDragging = true;
            state.startX = clientX;
            state.startY = clientY;
            state.currentDragMagnitude = 0;
            container.style.cursor = 'grabbing';
            imgElement.style.transition = 'none';
        }

        function onDrag(clientX, clientY) {
            if (!state.isDragging) return;
            
            const deltaX = clientX - state.startX;
            const deltaY = clientY - state.startY;
            
            // AQUÍ ESTÁ EL CAMBIO CLAVE:
            // No cambiamos la foto. Solo le decimos al sistema "El dedo está aquí ahora".
            // El loopRender se encargará de correr hasta aquí.
            state.targetDragX += deltaX;
            state.targetDragY += deltaY;
            
            // Calculamos magnitud para el zoom
            state.currentDragMagnitude += Math.sqrt(deltaX*deltaX + deltaY*deltaY); 

            state.startX = clientX;
            state.startY = clientY;
        }

        function stopDrag() {
            state.isDragging = false;
            container.style.cursor = 'grab';
            imgElement.style.transition = 'transform 0.5s ease-in-out';
            
            // Reseteamos el zoom (la escala vuelve a 1)
            // Nota: No reseteamos currentDragMagnitude instantáneamente a 0 aquí 
            // para permitir que la transición CSS haga el trabajo visual suave.
            state.currentDragMagnitude = 0; 
        }

        // Listeners Mouse
        container.addEventListener('mousedown', (e) => { e.preventDefault(); startDrag(e.clientX, e.clientY); });
        window.addEventListener('mousemove', (e) => { if(state.isDragging) onDrag(e.clientX, e.clientY); });
        window.addEventListener('mouseup', stopDrag);
        window.addEventListener('mouseleave', stopDrag);

        // Listeners Táctil
        container.addEventListener('touchstart', (e) => { const t = e.touches[0]; startDrag(t.clientX, t.clientY); }, { passive: false });
        window.addEventListener('touchmove', (e) => { if (state.isDragging) { const t = e.touches[0]; onDrag(t.clientX, t.clientY); } }, { passive: false });
        window.addEventListener('touchend', stopDrag);

        // ==========================================
        // MODO DEMO
        // ==========================================
        function activarModoDemo() {
            demoActive = true;
            imgElement.style.display = 'none';
            demoCanvas.style.display = 'block';
            demoCanvas.width = container.clientWidth;
            demoCanvas.height = container.clientHeight;
        }
        function drawDemoCube(x, y, name) {
            const ctx = demoCanvas.getContext('2d');
            const w = demoCanvas.width; const h = demoCanvas.height;
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = "#111"; ctx.fillRect(0,0,w,h);
            ctx.save(); ctx.translate(w/2, h/2);
            let progress = Math.min(state.currentDragMagnitude / config.sensitivity, 1.0);
            let s = 1 + (progress * config.maxZoomDelta);
            ctx.scale(s, s);
            ctx.scale(1.56, 1); 
            const rotX = (x - 8) * 15; const rotY = (y - 8) * 10;
            ctx.strokeStyle = "#666"; ctx.lineWidth = 2;
            ctx.strokeRect(-100 + rotX, -100 + rotY, 200 - rotX/2, 200 - rotY/2);
            ctx.font = "14px sans-serif"; ctx.fillStyle = "#888"; ctx.textAlign = "center";
            ctx.fillText("MODO SIN SALTOS", 0, -10);
            ctx.fillText(name.split('/').pop(), 0, 20);
            ctx.restore();
        }
        window.addEventListener('resize', () => { if(demoActive) { demoCanvas.width = container.clientWidth; demoCanvas.height = container.clientHeight; }});

    </script>
</body>
</html>

